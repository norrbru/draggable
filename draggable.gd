@icon("res://addons/custom-node-icons/control/icon_hand.svg")
class_name Draggable extends Control
## Makes any Control draggable with juicy movements.
##
## This is made to be applied on any Control node. Requires a child TextureRect
## with an attached 2D_perspective shader.
## Includes "popping" and (false) 3D rotation on mouse hover as well as a 
## dynamic shadow.

# TODO: Add area, or some way of detecting where it's dropped! Separate DropArea node?
# TODO: Make sure this works for touch controls and other types of controls, not just the mouse.

## When released over one of these Control nodes, Draggable will emit the drag_successful signal
## and pass along the drop_area it has been dropped over.
@export var drop_areas: Array[Control]

## The "face" of our draggable. What gets affected by the various visual effects?
## Should be used with something like a TextureRect. Without this, we still get
## most dragging functionality, just without the 3D and shadow effects.
@export var face: TextureRect

## Control node that determines the bounds of this Draggable. Self by default. Useful when using 
## child contianers, for example.
@export var bounds_override: Control

@export_group("Behavior")
## If true, will snap back to its original position if released without 
## dropping on an area. Should be set to false when hitting an area that we want 
## something to happen on.
@export var return_on_release: bool = false
@export var return_speed: float = 0.5
var _return_position: Vector2
var return_transition_type: Tween.TransitionType
var tween_return: Tween

## If enabled, all children of this Draggable except for the assigned face will be faded away during drag, then brought back on release. Requires face to be assigned.
@export var fade_children_on_drag: bool = false
## Speed of fade animation.
@export var fading_speed: float = 0.4
var _original_alphas: Dictionary = {}

# Rotation 2D
@export_group("Rotation 2D", "rotation_2d")
## If enabled, this Draggable's rotation will be affected by a damped oscillator while dragging.
@export var rotation_2d_enabled: bool = true
@export var rotation_2d_spring: float = 300.0
@export var rotation_2d_dampen: float = 30.0
@export var rotation_2d_velocity_multiplier: float = 0.3

@export_group("Rotation 3D", "rotation_3d")
## If enabled, this Draggable  will simulate 3D rotation when the mouse hovers over it. This is done via a ShaderMaterial script that is generated by the script.
@export var rotation_3d_enabled: bool = true
## Maximum angle limits for the simulated 3D rotation. 
@export var rotation_3d_max_angle: Vector2 = Vector2(6.0, 6.0)
@export var rotation_3d_fov: float = 90.0

@export_group("Scaling", "scaling")
@export var scaling_enabled: bool = true
@export var scaling_final_size_multiplier: float = 1.05
@export var scaling_speed: float = 0.4

@export_group("Shadow", "shadow")
## If enabled, a shadow is generated by duplicating the face node with a darker color. The duplicate's scripts and materials are removed.
@export var shadow_enabled: bool = true
@export var shadow_max_offset: float = 20.0
var shadow: Control

var consumed: bool = false

# Tweens
var tween_rot: Tween
var tween_rot_2d: Tween
var tween_hover: Tween
var tween_fade: Tween

# Dragging signals
signal drag_started()
signal drag_moved()
signal drag_released()
signal drag_successful(drop_area: Control)

# Card mouse dragging
var _following_mouse: bool = false
var _aligning_to_center: bool = false # Handles snapping to center of mouse
var _align_speed: float = 20.0 # Higher = faster initial snap

var _last_position: Vector2
var _displacement: float = 0.0
var _oscillator_velocity: float = 0.0
var _velocity: Vector2

# Generated shader_material
var _shader_material: ShaderMaterial

static var _instances: Array = []

func _ready() -> void:
	# Keep track of existing Draggable objects
	_instances.append(self)
	
	if return_on_release == false and get_parent() is Container:
		push_warning(self.name, " has return_on_release set to false, but is a child of a Container node. You might run into issues with input ordering, as that's based on sibling node order, not z_index. ")
	
	# Make sure our bounds_override act as the clickable area
	var b = _get_bounds()
	if b != self:
		b.mouse_filter = Control.MOUSE_FILTER_STOP
		self.mouse_filter = Control.MOUSE_FILTER_PASS # don't double-consume
	
	# Register input from the node acting as our bounds
	_get_bounds().gui_input.connect(_on_gui_input)
	_get_bounds().mouse_entered.connect(_on_mouse_entered)
	_get_bounds().mouse_exited.connect(_on_mouse_exited)
	
	if face != null:
		# Shrink center to correctly calculate image shadows etc
		## BUG: This should not be handled by this script, but removing it causes issues with the shadow
		## not stretching correctly. Fix later.
		face.size_flags_horizontal = Control.SIZE_SHRINK_CENTER
		face.size_flags_vertical = Control.SIZE_SHRINK_CENTER
		_assign_shader_material()
	
	# Generates a copy of face to use as its own shadow
	if shadow_enabled:
		create_shadow()


func _exit_tree() -> void:
	# Remove self from Draggable instances list
	_instances.erase(self)

func _process(delta: float) -> void:
	_handle_spring_rotation(delta)
	_handle_mouse_alignment(delta)
	_handle_shadow()

func _on_gui_input(event: InputEvent) -> void:
	if consumed: return
	
	if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT:
		if event.pressed:
			_on_pick_up() # Pick up Draggable
		else:
			_on_drop() # Release Draggable
		
	elif event is InputEventMouseMotion:
		if _following_mouse or _aligning_to_center:
			_on_movement()
		else:
			_on_mouse_hover() # Mouse hovering over Draggable, but not clicking

func _on_mouse_entered() -> void:
	if consumed: return
	# Cancel card rotation if mouse enters
	if tween_rot and tween_rot.is_running():
		tween_rot.kill()
	#_apply_scale() # Should the Draggable jump on mouse hover, not only click?

func _on_mouse_exited() -> void:
	if consumed: return
	if _following_mouse or _aligning_to_center: return # Guard against overlapping Controls
	_reset_scale()
	_handle_3d_rotation()

## Creates a new shadow for this object. Can include a fade-in if speed 
## is set to > 0.0. Meant for use during runtime.
func create_shadow(speed:float = 0.5):
	if face == null: return
	if shadow != null:
		push_warning(self.name, " already has a shadow, won't create new one!")
		return
	
	shadow = face.duplicate()
	shadow.name = "Gen_" + face.name + "Shadow"
	shadow.material = null
	shadow.set_script(null)
	shadow.show_behind_parent = true
	
	shadow.modulate = Color(0.0, 0.0, 0.0, 0.0)
	face.add_child(shadow)
	
	var tween: Tween = create_tween().set_ease(Tween.EASE_IN).set_trans(Tween.TRANS_LINEAR)
	tween.tween_property(shadow, "modulate:a", 0.3, speed)

## Disable the shadow, if any, by fade-out. Pass an argument of 0.0 to disable the animation. Meant for use during runtime.
func remove_shadow(speed: float = 0.2):
	if !shadow: 
		return
	
	var tween: Tween = create_tween().set_ease(Tween.EASE_IN).set_trans(Tween.TRANS_LINEAR)
	tween.tween_property(shadow, "modulate:a", 0.0, speed)
	tween.tween_callback(shadow.queue_free)


## Stops all active animations and disables input. Use this with a custom "destroy" animation when
## you want to remove this Draggable from the game.
func consume() -> void:
	if consumed: return # no need to repeat
	consumed = true
	
	face.use_parent_material = true # make the face respect the parent's mat
	
	#if tween_fade and tween_fade.is_running(): tween_fade.kill()
	if tween_return and tween_return.is_running(): tween_return.kill()
	if tween_hover and tween_hover.is_running(): tween_hover.kill()
	
	#print(self, " has been consumed.")

func unconsume() -> void:
	consumed = false
	face.use_parent_material = false


func _get_bounds() -> Control:
	if bounds_override != null:
		return bounds_override
	
	# Fallback to self
	return self

## Called in when the Draggable is "picked up" via click/tap.
func _on_pick_up() -> void:
	# sort all instances by current z_index, reassign clean values, put self on top
	_instances.sort_custom(func(a, b): return a.z_index < b.z_index)
	var sort_counter = 0
	for instance in _instances:
		if instance != self:
			instance.z_index = sort_counter
			sort_counter += 1
	z_index = _instances.size() - 1
	
	if tween_return and tween_return.is_running(): 
		tween_return.kill()
	else:
		_return_position = global_position
	_aligning_to_center = true # Starts alignment phase
	_following_mouse = false
	_apply_scale()
	
	# Fade out children other than face.
	_handle_fading(false)
	
	drag_started.emit()
	
	print(pivot_offset, " ", pivot_offset_ratio)


## Called when the Draggable has been released.
func _on_drop() -> void: 
	_aligning_to_center = false
	_following_mouse = false
	_reset_scale()
	if tween_rot and tween_rot.is_running(): tween_rot.kill()
		
	# Reset draggable's 2D rotation
	tween_rot_2d = create_tween().set_ease(Tween.EASE_OUT).set_trans(Tween.TRANS_EXPO)
	tween_rot_2d.tween_property(self, "rotation", 0.0, 0.5)
	_displacement = 0.0
	_oscillator_velocity = 0.0
	
	# checking if we've been dropped successfully
	var my_rect = _get_bounds().get_global_rect()
	for area in drop_areas:
		if area and area.get_global_rect().intersects(my_rect):
			drag_successful.emit(area)
	
	drag_released.emit()
	
	if not consumed:
		# Fade hidden children back in.
		_handle_fading(true)
		# Snap back to original position
		if return_on_release:
			tween_return = create_tween().set_ease(Tween.EASE_OUT).set_trans(Tween.TRANS_CUBIC)
			tween_return.tween_property(self, "global_position", _return_position, return_speed)

## Called when the Draggable is moved while held down.
func _on_movement() -> void:
	drag_moved.emit()


## Called when the mouse is hovering over (but NOT holding down) the Draggable.
func _on_mouse_hover() -> void:
	# Update 3D Rotation on mouse hover
	var mouse_pos: Vector2 = _get_bounds().get_local_mouse_position()
	var lerp_val_x: float = remap(mouse_pos.x, 0.0, _get_bounds().size.x, 0, 1)
	var lerp_val_y: float = remap(mouse_pos.y, 0.0, _get_bounds().size.y, 0, 1)
	
	var rot_x: float = rad_to_deg(lerp_angle(deg_to_rad(-rotation_3d_max_angle.x), deg_to_rad(rotation_3d_max_angle.x), lerp_val_x))
	var rot_y: float = rad_to_deg(lerp_angle(deg_to_rad(rotation_3d_max_angle.y), deg_to_rad(-rotation_3d_max_angle.y), lerp_val_y))
	
	_handle_3d_rotation(.2, rot_x, rot_y)


func _handle_spring_rotation(delta: float) -> void:
	if not rotation_2d_enabled: return
	# If Draggable isn't moving, don't rotate.
	# FIXME: Shouldn't rotate when snapping to mouse UNLESS mouse moves rapidly.
	if not _following_mouse and not _aligning_to_center: return
	
	if tween_rot_2d and tween_rot_2d.is_running():
		tween_rot_2d.kill()
	
	_velocity = (position - _last_position) / delta
	_last_position = position
	
	_oscillator_velocity += _velocity.normalized().x * rotation_2d_velocity_multiplier
	
	var force = -rotation_2d_spring * _displacement - rotation_2d_dampen * _oscillator_velocity
	_oscillator_velocity += force * delta
	_displacement += _oscillator_velocity * delta
	
	rotation = _displacement

func _handle_mouse_alignment(delta: float) -> void:
	# align to mouse
	if _aligning_to_center:
		var mouse_center = get_global_mouse_position() - _get_bounds().size * scale * pivot_offset_ratio
		global_position = global_position.lerp(mouse_center, _align_speed * delta)
		
		if global_position.distance_to(mouse_center) < 2.0:
			global_position = mouse_center
			_aligning_to_center = false
			_following_mouse = true
		
		_handle_3d_rotation()
	
	# Move with mouse. 
	elif _following_mouse:
		global_position = get_global_mouse_position() - _get_bounds().size * scale * pivot_offset_ratio



## Applies or resets 3D rotation to baseline via shader parameters. 
## If called without parameters, resets rotation.
func _handle_3d_rotation(speed: float = 0.5, target_x: float = 0.0, target_y: float = 0.0) -> void:
	if !rotation_3d_enabled or face == null or not face is TextureRect: return
	
	if tween_rot and tween_rot.is_running():
		tween_rot.kill()
	tween_rot = create_tween().set_ease(Tween.EASE_OUT).set_trans(Tween.TRANS_BACK).set_parallel(true)
	tween_rot.tween_property(face.material, "shader_parameter/x_rot", target_y, speed)
	tween_rot.tween_property(face.material, "shader_parameter/y_rot", target_x, speed)

## TODO: Add shadow Y offset as well, with a toggle to enable it or not
func _handle_shadow() -> void:
	if not shadow or shadow.visible == false or face == null: return
	
	# Offset the shadow from the face's position
	var viewport_center_x: float = get_viewport_rect().size.x / 2.0
	var texture_center_x: float = face.global_position.x + face.size.x / 2.0
	
	var offset_distance: float = texture_center_x - viewport_center_x
	
	shadow.position.x = lerp(0.0, (-sign(offset_distance) * shadow_max_offset), 
		abs(offset_distance/viewport_center_x))

## Fades out children other than the face
func _handle_fading(should_be_visible: bool) -> void:
	if !fade_children_on_drag or consumed: return
	if tween_fade and tween_fade.is_running():
		tween_fade.kill()
	var children = get_children()
	
	# Store original alphas on first run
	if _original_alphas.is_empty():
		for child in children:
			if child is CanvasItem:
				_original_alphas[child] = child.modulate.a
	
	tween_fade = create_tween().set_ease(Tween.EASE_OUT).set_trans(Tween.TRANS_QUAD).set_parallel(true)
	
	for child in children:
		if child is CanvasItem and child != face:
			var target_alpha = _original_alphas.get(child, 1.0) if should_be_visible else 0.0
			tween_fade.tween_property(child, "modulate:a", target_alpha, fading_speed)


# Card "bounce" animation that happens when clicked
func _apply_scale():
	if tween_hover and tween_hover.is_running():
		tween_hover.kill()
	tween_hover = create_tween().set_ease(Tween.EASE_OUT).set_trans(Tween.TRANS_EXPO)
	tween_hover.tween_property(self, "scale", Vector2.ONE * scaling_final_size_multiplier, scaling_speed)
	
	if tween_rot and tween_rot.is_running():
		tween_rot.kill()

# Cancel card "bounce" anim
func _reset_scale():
	if tween_hover and tween_hover.is_running():
		tween_hover.kill()
	tween_hover = create_tween().set_ease(Tween.EASE_OUT).set_trans(Tween.TRANS_EXPO)
	tween_hover.tween_property(self, "scale", Vector2.ONE, scaling_speed/2)

## Create and assign a false 3D rotation shader to the Control's face.
func _assign_shader_material():
	if not face is TextureRect:
		push_warning(self.name, ": 3D rotation requires face to be a TextureRect. Skipping shader.")
		return
	
	if face.material != null:
		push_warning("WARNING: ", self.name, "'s face node had an assigned Material that 
			has been replaced with a false 3D perspective ShaderMaterial.")
	
	var shader = Shader.new()
	
	shader.set_code("""
		// This shader "fakes" a 3D-camera perspective on CanvasItems.
		// Shader created by "Hei". MIT License.
		
		shader_type canvas_item;
		
		uniform vec2 rect_size;

		// Camera FOV
		uniform float fov : hint_range(1, 179) = 90;
		uniform bool cull_back = true;
		uniform float y_rot : hint_range(-180, 180) = 0.0;
		uniform float x_rot : hint_range(-180, 180) = 0.0;
		// At 0, the image retains its size when unrotated.
		// At 1, the image is resized so that it can do a full
		// rotation without clipping inside its rect.
		uniform float inset : hint_range(0, 1) = 0.0;
		// Consider changing this to a uniform and changing it from code

		varying flat vec2 o;
		varying vec3 p;

		// Creates rotation matrix
		void vertex(){
			float sin_b = sin(y_rot / 180.0 * PI);
			float cos_b = cos(y_rot / 180.0 * PI);
			float sin_c = sin(x_rot / 180.0 * PI);
			float cos_c = cos(x_rot / 180.0 * PI);
			
			mat3 inv_rot_mat;
			inv_rot_mat[0][0] = cos_b;
			inv_rot_mat[0][1] = 0.0;
			inv_rot_mat[0][2] = -sin_b;
			
			inv_rot_mat[1][0] = sin_b * sin_c;
			inv_rot_mat[1][1] = cos_c;
			inv_rot_mat[1][2] = cos_b * sin_c;
			
			inv_rot_mat[2][0] = sin_b * cos_c;
			inv_rot_mat[2][1] = -sin_c;
			inv_rot_mat[2][2] = cos_b * cos_c;
			
			
			float t = tan(fov / 360.0 * PI);
			p = inv_rot_mat * vec3((UV - 0.5), 0.5 / t);
			float v = (0.5 / t) + 0.5;
			p.xy *= v * inv_rot_mat[2].z;
			o = v * inv_rot_mat[2].xy;

			//VERTEX += (UV - 0.5) / TEXTURE_PIXEL_SIZE * t * (1.0 - inset);
			// to (rect_size is a uniform):
			VERTEX += (UV - 0.5) * rect_size * t * (1.0 - inset);
		}

		void fragment(){
			if (cull_back && p.z <= 0.0) discard;
			vec2 uv = (p.xy / p.z).xy - o;
			COLOR = texture(TEXTURE, uv + 0.5);
			COLOR.a *= step(max(abs(uv.x), abs(uv.y)), 0.5);
		}"""
		)
	
	_shader_material = ShaderMaterial.new()
	_shader_material.shader = shader
	face.material = _shader_material
	
	# Explicitly register ALL uniforms
	# If generating shaders from a script, you have to explicitly set these
	# in code. Who knew??!
	_shader_material.set_shader_parameter("rect_size", face.size)
	_shader_material.set_shader_parameter("x_rot", 0.0)
	_shader_material.set_shader_parameter("y_rot", 0.0)
	_shader_material.set_shader_parameter("fov", rotation_3d_fov)
	_shader_material.set_shader_parameter("inset", 0.0)
	_shader_material.set_shader_parameter("cull_back", true)
	
	# If the face's size changes, change it in the shader as well.
	face.resized.connect(func():
		_shader_material.set_shader_parameter("rect_size", face.size))
